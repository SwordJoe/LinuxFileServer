// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Message_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Message_2eproto;
class Cd;
struct CdDefaultTypeInternal;
extern CdDefaultTypeInternal _Cd_default_instance_;
class Cmd;
struct CmdDefaultTypeInternal;
extern CmdDefaultTypeInternal _Cmd_default_instance_;
class Get;
struct GetDefaultTypeInternal;
extern GetDefaultTypeInternal _Get_default_instance_;
class LS;
struct LSDefaultTypeInternal;
extern LSDefaultTypeInternal _LS_default_instance_;
class Mkdir;
struct MkdirDefaultTypeInternal;
extern MkdirDefaultTypeInternal _Mkdir_default_instance_;
class Put;
struct PutDefaultTypeInternal;
extern PutDefaultTypeInternal _Put_default_instance_;
class TrainMessage;
struct TrainMessageDefaultTypeInternal;
extern TrainMessageDefaultTypeInternal _TrainMessage_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Cd* Arena::CreateMaybeMessage<::Cd>(Arena*);
template<> ::Cmd* Arena::CreateMaybeMessage<::Cmd>(Arena*);
template<> ::Get* Arena::CreateMaybeMessage<::Get>(Arena*);
template<> ::LS* Arena::CreateMaybeMessage<::LS>(Arena*);
template<> ::Mkdir* Arena::CreateMaybeMessage<::Mkdir>(Arena*);
template<> ::Put* Arena::CreateMaybeMessage<::Put>(Arena*);
template<> ::TrainMessage* Arena::CreateMaybeMessage<::TrainMessage>(Arena*);
template<> ::UserInfo* Arena::CreateMaybeMessage<::UserInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class Cmd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Cmd) */ {
 public:
  inline Cmd() : Cmd(nullptr) {}
  ~Cmd() override;
  explicit constexpr Cmd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cmd(const Cmd& from);
  Cmd(Cmd&& from) noexcept
    : Cmd() {
    *this = ::std::move(from);
  }

  inline Cmd& operator=(const Cmd& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cmd& operator=(Cmd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cmd& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kUserinfo = 2,
    kLsinfo = 3,
    kMkdirinfo = 4,
    kCdinfo = 5,
    kPutinfo = 6,
    kGetinfo = 7,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Cmd* internal_default_instance() {
    return reinterpret_cast<const Cmd*>(
               &_Cmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Cmd& a, Cmd& b) {
    a.Swap(&b);
  }
  inline void Swap(Cmd* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cmd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cmd* New() const final {
    return new Cmd();
  }

  Cmd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cmd>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cmd& from);
  void MergeFrom(const Cmd& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cmd* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Cmd";
  }
  protected:
  explicit Cmd(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdidFieldNumber = 1,
    kUserinfoFieldNumber = 2,
    kLsinfoFieldNumber = 3,
    kMkdirinfoFieldNumber = 4,
    kCdinfoFieldNumber = 5,
    kPutinfoFieldNumber = 6,
    kGetinfoFieldNumber = 7,
  };
  // int32 cmdid = 1;
  void clear_cmdid();
  ::PROTOBUF_NAMESPACE_ID::int32 cmdid() const;
  void set_cmdid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cmdid() const;
  void _internal_set_cmdid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .UserInfo userinfo = 2;
  bool has_userinfo() const;
  private:
  bool _internal_has_userinfo() const;
  public:
  void clear_userinfo();
  const ::UserInfo& userinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::UserInfo* release_userinfo();
  ::UserInfo* mutable_userinfo();
  void set_allocated_userinfo(::UserInfo* userinfo);
  private:
  const ::UserInfo& _internal_userinfo() const;
  ::UserInfo* _internal_mutable_userinfo();
  public:
  void unsafe_arena_set_allocated_userinfo(
      ::UserInfo* userinfo);
  ::UserInfo* unsafe_arena_release_userinfo();

  // .LS lsinfo = 3;
  bool has_lsinfo() const;
  private:
  bool _internal_has_lsinfo() const;
  public:
  void clear_lsinfo();
  const ::LS& lsinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::LS* release_lsinfo();
  ::LS* mutable_lsinfo();
  void set_allocated_lsinfo(::LS* lsinfo);
  private:
  const ::LS& _internal_lsinfo() const;
  ::LS* _internal_mutable_lsinfo();
  public:
  void unsafe_arena_set_allocated_lsinfo(
      ::LS* lsinfo);
  ::LS* unsafe_arena_release_lsinfo();

  // .Mkdir mkdirinfo = 4;
  bool has_mkdirinfo() const;
  private:
  bool _internal_has_mkdirinfo() const;
  public:
  void clear_mkdirinfo();
  const ::Mkdir& mkdirinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Mkdir* release_mkdirinfo();
  ::Mkdir* mutable_mkdirinfo();
  void set_allocated_mkdirinfo(::Mkdir* mkdirinfo);
  private:
  const ::Mkdir& _internal_mkdirinfo() const;
  ::Mkdir* _internal_mutable_mkdirinfo();
  public:
  void unsafe_arena_set_allocated_mkdirinfo(
      ::Mkdir* mkdirinfo);
  ::Mkdir* unsafe_arena_release_mkdirinfo();

  // .Cd cdinfo = 5;
  bool has_cdinfo() const;
  private:
  bool _internal_has_cdinfo() const;
  public:
  void clear_cdinfo();
  const ::Cd& cdinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Cd* release_cdinfo();
  ::Cd* mutable_cdinfo();
  void set_allocated_cdinfo(::Cd* cdinfo);
  private:
  const ::Cd& _internal_cdinfo() const;
  ::Cd* _internal_mutable_cdinfo();
  public:
  void unsafe_arena_set_allocated_cdinfo(
      ::Cd* cdinfo);
  ::Cd* unsafe_arena_release_cdinfo();

  // .Put putinfo = 6;
  bool has_putinfo() const;
  private:
  bool _internal_has_putinfo() const;
  public:
  void clear_putinfo();
  const ::Put& putinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Put* release_putinfo();
  ::Put* mutable_putinfo();
  void set_allocated_putinfo(::Put* putinfo);
  private:
  const ::Put& _internal_putinfo() const;
  ::Put* _internal_mutable_putinfo();
  public:
  void unsafe_arena_set_allocated_putinfo(
      ::Put* putinfo);
  ::Put* unsafe_arena_release_putinfo();

  // .Get getinfo = 7;
  bool has_getinfo() const;
  private:
  bool _internal_has_getinfo() const;
  public:
  void clear_getinfo();
  const ::Get& getinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Get* release_getinfo();
  ::Get* mutable_getinfo();
  void set_allocated_getinfo(::Get* getinfo);
  private:
  const ::Get& _internal_getinfo() const;
  ::Get* _internal_mutable_getinfo();
  public:
  void unsafe_arena_set_allocated_getinfo(
      ::Get* getinfo);
  ::Get* unsafe_arena_release_getinfo();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:Cmd)
 private:
  class _Internal;
  void set_has_userinfo();
  void set_has_lsinfo();
  void set_has_mkdirinfo();
  void set_has_cdinfo();
  void set_has_putinfo();
  void set_has_getinfo();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 cmdid_;
  union PayloadUnion {
    constexpr PayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::UserInfo* userinfo_;
    ::LS* lsinfo_;
    ::Mkdir* mkdirinfo_;
    ::Cd* cdinfo_;
    ::Put* putinfo_;
    ::Get* getinfo_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class UserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  explicit constexpr UserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserInfo* New() const final {
    return new UserInfo();
  }

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswdFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string passwd = 2;
  void clear_passwd();
  const std::string& passwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwd();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_passwd();
  void set_allocated_passwd(std::string* passwd);
  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(const std::string& value);
  std::string* _internal_mutable_passwd();
  public:

  // @@protoc_insertion_point(class_scope:UserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class LS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LS) */ {
 public:
  inline LS() : LS(nullptr) {}
  ~LS() override;
  explicit constexpr LS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LS(const LS& from);
  LS(LS&& from) noexcept
    : LS() {
    *this = ::std::move(from);
  }

  inline LS& operator=(const LS& from) {
    CopyFrom(from);
    return *this;
  }
  inline LS& operator=(LS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LS& default_instance() {
    return *internal_default_instance();
  }
  static inline const LS* internal_default_instance() {
    return reinterpret_cast<const LS*>(
               &_LS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LS& a, LS& b) {
    a.Swap(&b);
  }
  inline void Swap(LS* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LS* New() const final {
    return new LS();
  }

  LS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LS>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LS& from);
  void MergeFrom(const LS& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LS* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LS";
  }
  protected:
  explicit LS(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurdirpathFieldNumber = 1,
  };
  // string curdirpath = 1;
  void clear_curdirpath();
  const std::string& curdirpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_curdirpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_curdirpath();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_curdirpath();
  void set_allocated_curdirpath(std::string* curdirpath);
  private:
  const std::string& _internal_curdirpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_curdirpath(const std::string& value);
  std::string* _internal_mutable_curdirpath();
  public:

  // @@protoc_insertion_point(class_scope:LS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr curdirpath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class Mkdir final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mkdir) */ {
 public:
  inline Mkdir() : Mkdir(nullptr) {}
  ~Mkdir() override;
  explicit constexpr Mkdir(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mkdir(const Mkdir& from);
  Mkdir(Mkdir&& from) noexcept
    : Mkdir() {
    *this = ::std::move(from);
  }

  inline Mkdir& operator=(const Mkdir& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mkdir& operator=(Mkdir&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mkdir& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mkdir* internal_default_instance() {
    return reinterpret_cast<const Mkdir*>(
               &_Mkdir_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Mkdir& a, Mkdir& b) {
    a.Swap(&b);
  }
  inline void Swap(Mkdir* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mkdir* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Mkdir* New() const final {
    return new Mkdir();
  }

  Mkdir* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Mkdir>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Mkdir& from);
  void MergeFrom(const Mkdir& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mkdir* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mkdir";
  }
  protected:
  explicit Mkdir(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurdirpathFieldNumber = 1,
    kDirnameFieldNumber = 2,
  };
  // string curdirpath = 1;
  void clear_curdirpath();
  const std::string& curdirpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_curdirpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_curdirpath();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_curdirpath();
  void set_allocated_curdirpath(std::string* curdirpath);
  private:
  const std::string& _internal_curdirpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_curdirpath(const std::string& value);
  std::string* _internal_mutable_curdirpath();
  public:

  // string dirname = 2;
  void clear_dirname();
  const std::string& dirname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dirname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dirname();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_dirname();
  void set_allocated_dirname(std::string* dirname);
  private:
  const std::string& _internal_dirname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dirname(const std::string& value);
  std::string* _internal_mutable_dirname();
  public:

  // @@protoc_insertion_point(class_scope:Mkdir)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr curdirpath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dirname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class Cd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Cd) */ {
 public:
  inline Cd() : Cd(nullptr) {}
  ~Cd() override;
  explicit constexpr Cd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cd(const Cd& from);
  Cd(Cd&& from) noexcept
    : Cd() {
    *this = ::std::move(from);
  }

  inline Cd& operator=(const Cd& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cd& operator=(Cd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cd& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cd* internal_default_instance() {
    return reinterpret_cast<const Cd*>(
               &_Cd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Cd& a, Cd& b) {
    a.Swap(&b);
  }
  inline void Swap(Cd* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cd* New() const final {
    return new Cd();
  }

  Cd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cd>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cd& from);
  void MergeFrom(const Cd& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cd* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Cd";
  }
  protected:
  explicit Cd(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirpathFieldNumber = 1,
  };
  // string dirpath = 1;
  void clear_dirpath();
  const std::string& dirpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dirpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dirpath();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_dirpath();
  void set_allocated_dirpath(std::string* dirpath);
  private:
  const std::string& _internal_dirpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dirpath(const std::string& value);
  std::string* _internal_mutable_dirpath();
  public:

  // @@protoc_insertion_point(class_scope:Cd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dirpath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class Put final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Put) */ {
 public:
  inline Put() : Put(nullptr) {}
  ~Put() override;
  explicit constexpr Put(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Put(const Put& from);
  Put(Put&& from) noexcept
    : Put() {
    *this = ::std::move(from);
  }

  inline Put& operator=(const Put& from) {
    CopyFrom(from);
    return *this;
  }
  inline Put& operator=(Put&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Put& default_instance() {
    return *internal_default_instance();
  }
  static inline const Put* internal_default_instance() {
    return reinterpret_cast<const Put*>(
               &_Put_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Put& a, Put& b) {
    a.Swap(&b);
  }
  inline void Swap(Put* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Put* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Put* New() const final {
    return new Put();
  }

  Put* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Put>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Put& from);
  void MergeFrom(const Put& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Put* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Put";
  }
  protected:
  explicit Put(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurdirpathFieldNumber = 1,
    kFilenameFieldNumber = 2,
    kMd5FieldNumber = 3,
    kFilesizeFieldNumber = 4,
  };
  // string curdirpath = 1;
  void clear_curdirpath();
  const std::string& curdirpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_curdirpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_curdirpath();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_curdirpath();
  void set_allocated_curdirpath(std::string* curdirpath);
  private:
  const std::string& _internal_curdirpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_curdirpath(const std::string& value);
  std::string* _internal_mutable_curdirpath();
  public:

  // string filename = 2;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string md5 = 3;
  void clear_md5();
  const std::string& md5() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_md5(ArgT0&& arg0, ArgT... args);
  std::string* mutable_md5();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_md5();
  void set_allocated_md5(std::string* md5);
  private:
  const std::string& _internal_md5() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_md5(const std::string& value);
  std::string* _internal_mutable_md5();
  public:

  // int32 filesize = 4;
  void clear_filesize();
  ::PROTOBUF_NAMESPACE_ID::int32 filesize() const;
  void set_filesize(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_filesize() const;
  void _internal_set_filesize(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Put)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr curdirpath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr md5_;
  ::PROTOBUF_NAMESPACE_ID::int32 filesize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class Get final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Get) */ {
 public:
  inline Get() : Get(nullptr) {}
  ~Get() override;
  explicit constexpr Get(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Get(const Get& from);
  Get(Get&& from) noexcept
    : Get() {
    *this = ::std::move(from);
  }

  inline Get& operator=(const Get& from) {
    CopyFrom(from);
    return *this;
  }
  inline Get& operator=(Get&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Get& default_instance() {
    return *internal_default_instance();
  }
  static inline const Get* internal_default_instance() {
    return reinterpret_cast<const Get*>(
               &_Get_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Get& a, Get& b) {
    a.Swap(&b);
  }
  inline void Swap(Get* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Get* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Get* New() const final {
    return new Get();
  }

  Get* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Get>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Get& from);
  void MergeFrom(const Get& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Get* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Get";
  }
  protected:
  explicit Get(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurdirpathFieldNumber = 1,
    kFilenameFieldNumber = 2,
  };
  // string curdirpath = 1;
  void clear_curdirpath();
  const std::string& curdirpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_curdirpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_curdirpath();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_curdirpath();
  void set_allocated_curdirpath(std::string* curdirpath);
  private:
  const std::string& _internal_curdirpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_curdirpath(const std::string& value);
  std::string* _internal_mutable_curdirpath();
  public:

  // string filename = 2;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // @@protoc_insertion_point(class_scope:Get)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr curdirpath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class TrainMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TrainMessage) */ {
 public:
  inline TrainMessage() : TrainMessage(nullptr) {}
  ~TrainMessage() override;
  explicit constexpr TrainMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrainMessage(const TrainMessage& from);
  TrainMessage(TrainMessage&& from) noexcept
    : TrainMessage() {
    *this = ::std::move(from);
  }

  inline TrainMessage& operator=(const TrainMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainMessage& operator=(TrainMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrainMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrainMessage* internal_default_instance() {
    return reinterpret_cast<const TrainMessage*>(
               &_TrainMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TrainMessage& a, TrainMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TrainMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrainMessage* New() const final {
    return new TrainMessage();
  }

  TrainMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrainMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrainMessage& from);
  void MergeFrom(const TrainMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrainMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TrainMessage";
  }
  protected:
  explicit TrainMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kDatalenFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // int32 datalen = 1;
  void clear_datalen();
  ::PROTOBUF_NAMESPACE_ID::int32 datalen() const;
  void set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_datalen() const;
  void _internal_set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:TrainMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::int32 datalen_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Cmd

// int32 cmdid = 1;
inline void Cmd::clear_cmdid() {
  cmdid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cmd::_internal_cmdid() const {
  return cmdid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cmd::cmdid() const {
  // @@protoc_insertion_point(field_get:Cmd.cmdid)
  return _internal_cmdid();
}
inline void Cmd::_internal_set_cmdid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cmdid_ = value;
}
inline void Cmd::set_cmdid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cmdid(value);
  // @@protoc_insertion_point(field_set:Cmd.cmdid)
}

// .UserInfo userinfo = 2;
inline bool Cmd::_internal_has_userinfo() const {
  return payload_case() == kUserinfo;
}
inline bool Cmd::has_userinfo() const {
  return _internal_has_userinfo();
}
inline void Cmd::set_has_userinfo() {
  _oneof_case_[0] = kUserinfo;
}
inline void Cmd::clear_userinfo() {
  if (_internal_has_userinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.userinfo_;
    }
    clear_has_payload();
  }
}
inline ::UserInfo* Cmd::release_userinfo() {
  // @@protoc_insertion_point(field_release:Cmd.userinfo)
  if (_internal_has_userinfo()) {
    clear_has_payload();
      ::UserInfo* temp = payload_.userinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.userinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UserInfo& Cmd::_internal_userinfo() const {
  return _internal_has_userinfo()
      ? *payload_.userinfo_
      : reinterpret_cast< ::UserInfo&>(::_UserInfo_default_instance_);
}
inline const ::UserInfo& Cmd::userinfo() const {
  // @@protoc_insertion_point(field_get:Cmd.userinfo)
  return _internal_userinfo();
}
inline ::UserInfo* Cmd::unsafe_arena_release_userinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Cmd.userinfo)
  if (_internal_has_userinfo()) {
    clear_has_payload();
    ::UserInfo* temp = payload_.userinfo_;
    payload_.userinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Cmd::unsafe_arena_set_allocated_userinfo(::UserInfo* userinfo) {
  clear_payload();
  if (userinfo) {
    set_has_userinfo();
    payload_.userinfo_ = userinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Cmd.userinfo)
}
inline ::UserInfo* Cmd::_internal_mutable_userinfo() {
  if (!_internal_has_userinfo()) {
    clear_payload();
    set_has_userinfo();
    payload_.userinfo_ = CreateMaybeMessage< ::UserInfo >(GetArenaForAllocation());
  }
  return payload_.userinfo_;
}
inline ::UserInfo* Cmd::mutable_userinfo() {
  // @@protoc_insertion_point(field_mutable:Cmd.userinfo)
  return _internal_mutable_userinfo();
}

// .LS lsinfo = 3;
inline bool Cmd::_internal_has_lsinfo() const {
  return payload_case() == kLsinfo;
}
inline bool Cmd::has_lsinfo() const {
  return _internal_has_lsinfo();
}
inline void Cmd::set_has_lsinfo() {
  _oneof_case_[0] = kLsinfo;
}
inline void Cmd::clear_lsinfo() {
  if (_internal_has_lsinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.lsinfo_;
    }
    clear_has_payload();
  }
}
inline ::LS* Cmd::release_lsinfo() {
  // @@protoc_insertion_point(field_release:Cmd.lsinfo)
  if (_internal_has_lsinfo()) {
    clear_has_payload();
      ::LS* temp = payload_.lsinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.lsinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LS& Cmd::_internal_lsinfo() const {
  return _internal_has_lsinfo()
      ? *payload_.lsinfo_
      : reinterpret_cast< ::LS&>(::_LS_default_instance_);
}
inline const ::LS& Cmd::lsinfo() const {
  // @@protoc_insertion_point(field_get:Cmd.lsinfo)
  return _internal_lsinfo();
}
inline ::LS* Cmd::unsafe_arena_release_lsinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Cmd.lsinfo)
  if (_internal_has_lsinfo()) {
    clear_has_payload();
    ::LS* temp = payload_.lsinfo_;
    payload_.lsinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Cmd::unsafe_arena_set_allocated_lsinfo(::LS* lsinfo) {
  clear_payload();
  if (lsinfo) {
    set_has_lsinfo();
    payload_.lsinfo_ = lsinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Cmd.lsinfo)
}
inline ::LS* Cmd::_internal_mutable_lsinfo() {
  if (!_internal_has_lsinfo()) {
    clear_payload();
    set_has_lsinfo();
    payload_.lsinfo_ = CreateMaybeMessage< ::LS >(GetArenaForAllocation());
  }
  return payload_.lsinfo_;
}
inline ::LS* Cmd::mutable_lsinfo() {
  // @@protoc_insertion_point(field_mutable:Cmd.lsinfo)
  return _internal_mutable_lsinfo();
}

// .Mkdir mkdirinfo = 4;
inline bool Cmd::_internal_has_mkdirinfo() const {
  return payload_case() == kMkdirinfo;
}
inline bool Cmd::has_mkdirinfo() const {
  return _internal_has_mkdirinfo();
}
inline void Cmd::set_has_mkdirinfo() {
  _oneof_case_[0] = kMkdirinfo;
}
inline void Cmd::clear_mkdirinfo() {
  if (_internal_has_mkdirinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.mkdirinfo_;
    }
    clear_has_payload();
  }
}
inline ::Mkdir* Cmd::release_mkdirinfo() {
  // @@protoc_insertion_point(field_release:Cmd.mkdirinfo)
  if (_internal_has_mkdirinfo()) {
    clear_has_payload();
      ::Mkdir* temp = payload_.mkdirinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.mkdirinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Mkdir& Cmd::_internal_mkdirinfo() const {
  return _internal_has_mkdirinfo()
      ? *payload_.mkdirinfo_
      : reinterpret_cast< ::Mkdir&>(::_Mkdir_default_instance_);
}
inline const ::Mkdir& Cmd::mkdirinfo() const {
  // @@protoc_insertion_point(field_get:Cmd.mkdirinfo)
  return _internal_mkdirinfo();
}
inline ::Mkdir* Cmd::unsafe_arena_release_mkdirinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Cmd.mkdirinfo)
  if (_internal_has_mkdirinfo()) {
    clear_has_payload();
    ::Mkdir* temp = payload_.mkdirinfo_;
    payload_.mkdirinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Cmd::unsafe_arena_set_allocated_mkdirinfo(::Mkdir* mkdirinfo) {
  clear_payload();
  if (mkdirinfo) {
    set_has_mkdirinfo();
    payload_.mkdirinfo_ = mkdirinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Cmd.mkdirinfo)
}
inline ::Mkdir* Cmd::_internal_mutable_mkdirinfo() {
  if (!_internal_has_mkdirinfo()) {
    clear_payload();
    set_has_mkdirinfo();
    payload_.mkdirinfo_ = CreateMaybeMessage< ::Mkdir >(GetArenaForAllocation());
  }
  return payload_.mkdirinfo_;
}
inline ::Mkdir* Cmd::mutable_mkdirinfo() {
  // @@protoc_insertion_point(field_mutable:Cmd.mkdirinfo)
  return _internal_mutable_mkdirinfo();
}

// .Cd cdinfo = 5;
inline bool Cmd::_internal_has_cdinfo() const {
  return payload_case() == kCdinfo;
}
inline bool Cmd::has_cdinfo() const {
  return _internal_has_cdinfo();
}
inline void Cmd::set_has_cdinfo() {
  _oneof_case_[0] = kCdinfo;
}
inline void Cmd::clear_cdinfo() {
  if (_internal_has_cdinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.cdinfo_;
    }
    clear_has_payload();
  }
}
inline ::Cd* Cmd::release_cdinfo() {
  // @@protoc_insertion_point(field_release:Cmd.cdinfo)
  if (_internal_has_cdinfo()) {
    clear_has_payload();
      ::Cd* temp = payload_.cdinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.cdinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Cd& Cmd::_internal_cdinfo() const {
  return _internal_has_cdinfo()
      ? *payload_.cdinfo_
      : reinterpret_cast< ::Cd&>(::_Cd_default_instance_);
}
inline const ::Cd& Cmd::cdinfo() const {
  // @@protoc_insertion_point(field_get:Cmd.cdinfo)
  return _internal_cdinfo();
}
inline ::Cd* Cmd::unsafe_arena_release_cdinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Cmd.cdinfo)
  if (_internal_has_cdinfo()) {
    clear_has_payload();
    ::Cd* temp = payload_.cdinfo_;
    payload_.cdinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Cmd::unsafe_arena_set_allocated_cdinfo(::Cd* cdinfo) {
  clear_payload();
  if (cdinfo) {
    set_has_cdinfo();
    payload_.cdinfo_ = cdinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Cmd.cdinfo)
}
inline ::Cd* Cmd::_internal_mutable_cdinfo() {
  if (!_internal_has_cdinfo()) {
    clear_payload();
    set_has_cdinfo();
    payload_.cdinfo_ = CreateMaybeMessage< ::Cd >(GetArenaForAllocation());
  }
  return payload_.cdinfo_;
}
inline ::Cd* Cmd::mutable_cdinfo() {
  // @@protoc_insertion_point(field_mutable:Cmd.cdinfo)
  return _internal_mutable_cdinfo();
}

// .Put putinfo = 6;
inline bool Cmd::_internal_has_putinfo() const {
  return payload_case() == kPutinfo;
}
inline bool Cmd::has_putinfo() const {
  return _internal_has_putinfo();
}
inline void Cmd::set_has_putinfo() {
  _oneof_case_[0] = kPutinfo;
}
inline void Cmd::clear_putinfo() {
  if (_internal_has_putinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.putinfo_;
    }
    clear_has_payload();
  }
}
inline ::Put* Cmd::release_putinfo() {
  // @@protoc_insertion_point(field_release:Cmd.putinfo)
  if (_internal_has_putinfo()) {
    clear_has_payload();
      ::Put* temp = payload_.putinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.putinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Put& Cmd::_internal_putinfo() const {
  return _internal_has_putinfo()
      ? *payload_.putinfo_
      : reinterpret_cast< ::Put&>(::_Put_default_instance_);
}
inline const ::Put& Cmd::putinfo() const {
  // @@protoc_insertion_point(field_get:Cmd.putinfo)
  return _internal_putinfo();
}
inline ::Put* Cmd::unsafe_arena_release_putinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Cmd.putinfo)
  if (_internal_has_putinfo()) {
    clear_has_payload();
    ::Put* temp = payload_.putinfo_;
    payload_.putinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Cmd::unsafe_arena_set_allocated_putinfo(::Put* putinfo) {
  clear_payload();
  if (putinfo) {
    set_has_putinfo();
    payload_.putinfo_ = putinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Cmd.putinfo)
}
inline ::Put* Cmd::_internal_mutable_putinfo() {
  if (!_internal_has_putinfo()) {
    clear_payload();
    set_has_putinfo();
    payload_.putinfo_ = CreateMaybeMessage< ::Put >(GetArenaForAllocation());
  }
  return payload_.putinfo_;
}
inline ::Put* Cmd::mutable_putinfo() {
  // @@protoc_insertion_point(field_mutable:Cmd.putinfo)
  return _internal_mutable_putinfo();
}

// .Get getinfo = 7;
inline bool Cmd::_internal_has_getinfo() const {
  return payload_case() == kGetinfo;
}
inline bool Cmd::has_getinfo() const {
  return _internal_has_getinfo();
}
inline void Cmd::set_has_getinfo() {
  _oneof_case_[0] = kGetinfo;
}
inline void Cmd::clear_getinfo() {
  if (_internal_has_getinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.getinfo_;
    }
    clear_has_payload();
  }
}
inline ::Get* Cmd::release_getinfo() {
  // @@protoc_insertion_point(field_release:Cmd.getinfo)
  if (_internal_has_getinfo()) {
    clear_has_payload();
      ::Get* temp = payload_.getinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.getinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Get& Cmd::_internal_getinfo() const {
  return _internal_has_getinfo()
      ? *payload_.getinfo_
      : reinterpret_cast< ::Get&>(::_Get_default_instance_);
}
inline const ::Get& Cmd::getinfo() const {
  // @@protoc_insertion_point(field_get:Cmd.getinfo)
  return _internal_getinfo();
}
inline ::Get* Cmd::unsafe_arena_release_getinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Cmd.getinfo)
  if (_internal_has_getinfo()) {
    clear_has_payload();
    ::Get* temp = payload_.getinfo_;
    payload_.getinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Cmd::unsafe_arena_set_allocated_getinfo(::Get* getinfo) {
  clear_payload();
  if (getinfo) {
    set_has_getinfo();
    payload_.getinfo_ = getinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Cmd.getinfo)
}
inline ::Get* Cmd::_internal_mutable_getinfo() {
  if (!_internal_has_getinfo()) {
    clear_payload();
    set_has_getinfo();
    payload_.getinfo_ = CreateMaybeMessage< ::Get >(GetArenaForAllocation());
  }
  return payload_.getinfo_;
}
inline ::Get* Cmd::mutable_getinfo() {
  // @@protoc_insertion_point(field_mutable:Cmd.getinfo)
  return _internal_mutable_getinfo();
}

inline bool Cmd::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Cmd::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Cmd::PayloadCase Cmd::payload_case() const {
  return Cmd::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UserInfo

// string username = 1;
inline void UserInfo::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& UserInfo::username() const {
  // @@protoc_insertion_point(field_get:UserInfo.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.username)
}
inline std::string* UserInfo::mutable_username() {
  // @@protoc_insertion_point(field_mutable:UserInfo.username)
  return _internal_mutable_username();
}
inline const std::string& UserInfo::_internal_username() const {
  return username_.Get();
}
inline void UserInfo::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_username() {
  // @@protoc_insertion_point(field_release:UserInfo.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:UserInfo.username)
}

// string passwd = 2;
inline void UserInfo::clear_passwd() {
  passwd_.ClearToEmpty();
}
inline const std::string& UserInfo::passwd() const {
  // @@protoc_insertion_point(field_get:UserInfo.passwd)
  return _internal_passwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_passwd(ArgT0&& arg0, ArgT... args) {
 
 passwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.passwd)
}
inline std::string* UserInfo::mutable_passwd() {
  // @@protoc_insertion_point(field_mutable:UserInfo.passwd)
  return _internal_mutable_passwd();
}
inline const std::string& UserInfo::_internal_passwd() const {
  return passwd_.Get();
}
inline void UserInfo::_internal_set_passwd(const std::string& value) {
  
  passwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_passwd() {
  
  return passwd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_passwd() {
  // @@protoc_insertion_point(field_release:UserInfo.passwd)
  return passwd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserInfo::set_allocated_passwd(std::string* passwd) {
  if (passwd != nullptr) {
    
  } else {
    
  }
  passwd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), passwd,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:UserInfo.passwd)
}

// -------------------------------------------------------------------

// LS

// string curdirpath = 1;
inline void LS::clear_curdirpath() {
  curdirpath_.ClearToEmpty();
}
inline const std::string& LS::curdirpath() const {
  // @@protoc_insertion_point(field_get:LS.curdirpath)
  return _internal_curdirpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LS::set_curdirpath(ArgT0&& arg0, ArgT... args) {
 
 curdirpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LS.curdirpath)
}
inline std::string* LS::mutable_curdirpath() {
  // @@protoc_insertion_point(field_mutable:LS.curdirpath)
  return _internal_mutable_curdirpath();
}
inline const std::string& LS::_internal_curdirpath() const {
  return curdirpath_.Get();
}
inline void LS::_internal_set_curdirpath(const std::string& value) {
  
  curdirpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LS::_internal_mutable_curdirpath() {
  
  return curdirpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LS::release_curdirpath() {
  // @@protoc_insertion_point(field_release:LS.curdirpath)
  return curdirpath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LS::set_allocated_curdirpath(std::string* curdirpath) {
  if (curdirpath != nullptr) {
    
  } else {
    
  }
  curdirpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), curdirpath,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:LS.curdirpath)
}

// -------------------------------------------------------------------

// Mkdir

// string curdirpath = 1;
inline void Mkdir::clear_curdirpath() {
  curdirpath_.ClearToEmpty();
}
inline const std::string& Mkdir::curdirpath() const {
  // @@protoc_insertion_point(field_get:Mkdir.curdirpath)
  return _internal_curdirpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mkdir::set_curdirpath(ArgT0&& arg0, ArgT... args) {
 
 curdirpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Mkdir.curdirpath)
}
inline std::string* Mkdir::mutable_curdirpath() {
  // @@protoc_insertion_point(field_mutable:Mkdir.curdirpath)
  return _internal_mutable_curdirpath();
}
inline const std::string& Mkdir::_internal_curdirpath() const {
  return curdirpath_.Get();
}
inline void Mkdir::_internal_set_curdirpath(const std::string& value) {
  
  curdirpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Mkdir::_internal_mutable_curdirpath() {
  
  return curdirpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Mkdir::release_curdirpath() {
  // @@protoc_insertion_point(field_release:Mkdir.curdirpath)
  return curdirpath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Mkdir::set_allocated_curdirpath(std::string* curdirpath) {
  if (curdirpath != nullptr) {
    
  } else {
    
  }
  curdirpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), curdirpath,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Mkdir.curdirpath)
}

// string dirname = 2;
inline void Mkdir::clear_dirname() {
  dirname_.ClearToEmpty();
}
inline const std::string& Mkdir::dirname() const {
  // @@protoc_insertion_point(field_get:Mkdir.dirname)
  return _internal_dirname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mkdir::set_dirname(ArgT0&& arg0, ArgT... args) {
 
 dirname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Mkdir.dirname)
}
inline std::string* Mkdir::mutable_dirname() {
  // @@protoc_insertion_point(field_mutable:Mkdir.dirname)
  return _internal_mutable_dirname();
}
inline const std::string& Mkdir::_internal_dirname() const {
  return dirname_.Get();
}
inline void Mkdir::_internal_set_dirname(const std::string& value) {
  
  dirname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Mkdir::_internal_mutable_dirname() {
  
  return dirname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Mkdir::release_dirname() {
  // @@protoc_insertion_point(field_release:Mkdir.dirname)
  return dirname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Mkdir::set_allocated_dirname(std::string* dirname) {
  if (dirname != nullptr) {
    
  } else {
    
  }
  dirname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dirname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Mkdir.dirname)
}

// -------------------------------------------------------------------

// Cd

// string dirpath = 1;
inline void Cd::clear_dirpath() {
  dirpath_.ClearToEmpty();
}
inline const std::string& Cd::dirpath() const {
  // @@protoc_insertion_point(field_get:Cd.dirpath)
  return _internal_dirpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cd::set_dirpath(ArgT0&& arg0, ArgT... args) {
 
 dirpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Cd.dirpath)
}
inline std::string* Cd::mutable_dirpath() {
  // @@protoc_insertion_point(field_mutable:Cd.dirpath)
  return _internal_mutable_dirpath();
}
inline const std::string& Cd::_internal_dirpath() const {
  return dirpath_.Get();
}
inline void Cd::_internal_set_dirpath(const std::string& value) {
  
  dirpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Cd::_internal_mutable_dirpath() {
  
  return dirpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Cd::release_dirpath() {
  // @@protoc_insertion_point(field_release:Cd.dirpath)
  return dirpath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Cd::set_allocated_dirpath(std::string* dirpath) {
  if (dirpath != nullptr) {
    
  } else {
    
  }
  dirpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dirpath,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Cd.dirpath)
}

// -------------------------------------------------------------------

// Put

// string curdirpath = 1;
inline void Put::clear_curdirpath() {
  curdirpath_.ClearToEmpty();
}
inline const std::string& Put::curdirpath() const {
  // @@protoc_insertion_point(field_get:Put.curdirpath)
  return _internal_curdirpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Put::set_curdirpath(ArgT0&& arg0, ArgT... args) {
 
 curdirpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Put.curdirpath)
}
inline std::string* Put::mutable_curdirpath() {
  // @@protoc_insertion_point(field_mutable:Put.curdirpath)
  return _internal_mutable_curdirpath();
}
inline const std::string& Put::_internal_curdirpath() const {
  return curdirpath_.Get();
}
inline void Put::_internal_set_curdirpath(const std::string& value) {
  
  curdirpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Put::_internal_mutable_curdirpath() {
  
  return curdirpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Put::release_curdirpath() {
  // @@protoc_insertion_point(field_release:Put.curdirpath)
  return curdirpath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Put::set_allocated_curdirpath(std::string* curdirpath) {
  if (curdirpath != nullptr) {
    
  } else {
    
  }
  curdirpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), curdirpath,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Put.curdirpath)
}

// string filename = 2;
inline void Put::clear_filename() {
  filename_.ClearToEmpty();
}
inline const std::string& Put::filename() const {
  // @@protoc_insertion_point(field_get:Put.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Put::set_filename(ArgT0&& arg0, ArgT... args) {
 
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Put.filename)
}
inline std::string* Put::mutable_filename() {
  // @@protoc_insertion_point(field_mutable:Put.filename)
  return _internal_mutable_filename();
}
inline const std::string& Put::_internal_filename() const {
  return filename_.Get();
}
inline void Put::_internal_set_filename(const std::string& value) {
  
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Put::_internal_mutable_filename() {
  
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Put::release_filename() {
  // @@protoc_insertion_point(field_release:Put.filename)
  return filename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Put::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Put.filename)
}

// string md5 = 3;
inline void Put::clear_md5() {
  md5_.ClearToEmpty();
}
inline const std::string& Put::md5() const {
  // @@protoc_insertion_point(field_get:Put.md5)
  return _internal_md5();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Put::set_md5(ArgT0&& arg0, ArgT... args) {
 
 md5_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Put.md5)
}
inline std::string* Put::mutable_md5() {
  // @@protoc_insertion_point(field_mutable:Put.md5)
  return _internal_mutable_md5();
}
inline const std::string& Put::_internal_md5() const {
  return md5_.Get();
}
inline void Put::_internal_set_md5(const std::string& value) {
  
  md5_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Put::_internal_mutable_md5() {
  
  return md5_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Put::release_md5() {
  // @@protoc_insertion_point(field_release:Put.md5)
  return md5_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Put::set_allocated_md5(std::string* md5) {
  if (md5 != nullptr) {
    
  } else {
    
  }
  md5_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), md5,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Put.md5)
}

// int32 filesize = 4;
inline void Put::clear_filesize() {
  filesize_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Put::_internal_filesize() const {
  return filesize_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Put::filesize() const {
  // @@protoc_insertion_point(field_get:Put.filesize)
  return _internal_filesize();
}
inline void Put::_internal_set_filesize(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  filesize_ = value;
}
inline void Put::set_filesize(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_filesize(value);
  // @@protoc_insertion_point(field_set:Put.filesize)
}

// -------------------------------------------------------------------

// Get

// string curdirpath = 1;
inline void Get::clear_curdirpath() {
  curdirpath_.ClearToEmpty();
}
inline const std::string& Get::curdirpath() const {
  // @@protoc_insertion_point(field_get:Get.curdirpath)
  return _internal_curdirpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Get::set_curdirpath(ArgT0&& arg0, ArgT... args) {
 
 curdirpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Get.curdirpath)
}
inline std::string* Get::mutable_curdirpath() {
  // @@protoc_insertion_point(field_mutable:Get.curdirpath)
  return _internal_mutable_curdirpath();
}
inline const std::string& Get::_internal_curdirpath() const {
  return curdirpath_.Get();
}
inline void Get::_internal_set_curdirpath(const std::string& value) {
  
  curdirpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Get::_internal_mutable_curdirpath() {
  
  return curdirpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Get::release_curdirpath() {
  // @@protoc_insertion_point(field_release:Get.curdirpath)
  return curdirpath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Get::set_allocated_curdirpath(std::string* curdirpath) {
  if (curdirpath != nullptr) {
    
  } else {
    
  }
  curdirpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), curdirpath,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Get.curdirpath)
}

// string filename = 2;
inline void Get::clear_filename() {
  filename_.ClearToEmpty();
}
inline const std::string& Get::filename() const {
  // @@protoc_insertion_point(field_get:Get.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Get::set_filename(ArgT0&& arg0, ArgT... args) {
 
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Get.filename)
}
inline std::string* Get::mutable_filename() {
  // @@protoc_insertion_point(field_mutable:Get.filename)
  return _internal_mutable_filename();
}
inline const std::string& Get::_internal_filename() const {
  return filename_.Get();
}
inline void Get::_internal_set_filename(const std::string& value) {
  
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Get::_internal_mutable_filename() {
  
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Get::release_filename() {
  // @@protoc_insertion_point(field_release:Get.filename)
  return filename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Get::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Get.filename)
}

// -------------------------------------------------------------------

// TrainMessage

// int32 datalen = 1;
inline void TrainMessage::clear_datalen() {
  datalen_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrainMessage::_internal_datalen() const {
  return datalen_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TrainMessage::datalen() const {
  // @@protoc_insertion_point(field_get:TrainMessage.datalen)
  return _internal_datalen();
}
inline void TrainMessage::_internal_set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  datalen_ = value;
}
inline void TrainMessage::set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_datalen(value);
  // @@protoc_insertion_point(field_set:TrainMessage.datalen)
}

// string msg = 2;
inline void TrainMessage::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& TrainMessage::msg() const {
  // @@protoc_insertion_point(field_get:TrainMessage.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainMessage::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TrainMessage.msg)
}
inline std::string* TrainMessage::mutable_msg() {
  // @@protoc_insertion_point(field_mutable:TrainMessage.msg)
  return _internal_mutable_msg();
}
inline const std::string& TrainMessage::_internal_msg() const {
  return msg_.Get();
}
inline void TrainMessage::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TrainMessage::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TrainMessage::release_msg() {
  // @@protoc_insertion_point(field_release:TrainMessage.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TrainMessage::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TrainMessage.msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Message_2eproto
